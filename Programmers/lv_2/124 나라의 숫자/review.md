### [124 나라의 숫자](https://programmers.co.kr/learn/courses/30/lessons/12899)

```js
/*
pseudo code

1, 2, 4로만 구성되므로 경우의 수를 통해 숫자를 표현한다고 생각
한 자릿수는 3 가지 경우
두 자릿수는 3 * 3 가지 경우

= 3 ** 1 + 3 ** 2 + 3 ** 3 + ...
등비수열의 합 공식을 이용해서 Sn = a * (r ** n - 1) / (r - 1)

let numberOfDigits = 1;
const sum = 3 / 2 * (3 ** numberOfDigits - 1)

while (sum < numberOfDigits)
  ++numberOfDigits;

---

3진법으로 숫자를 변형하고
+[...number].map(digit => digit === 4 ? 3 : digit).join('');

---

n진법으로 바꿀 때 어떠한 숫자를 n으로 나누고 나머지를 가장 마지막 자리에 두고
몫을 다시 n으로 나누고 나머지를 가장 마지막에서 두번째 자리에 두고
... 를 반복하여 몫이 0이 될때까지 반복한다

 1 / 3 ==> 몫 0, 나머지 1 ==> 1
 1 / 2 ==> 몫 0, 나머지 2 ==> 2
 3 / 3 ==> 몫 1, 나머지 0 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 10 ==> 4
 4 / 3 ==> 몫 1, 나머지 1 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 11 ==> 11
 5 / 3 ==> 몫 1, 나머지 2 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 12 ==> 12
 6 / 2 ==> 몫 2, 나머지 0 ==> 2 / 3 ==> 몫 0, 나머지 2 ==> 20 ==> 14
 7 / 2 ==> 몫 2, 나머지 1 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 21 ==> 21
 8 / 2 ==> 몫 2, 나머지 2 ==> 2 / 3 ==> 몫 0, 나머지 2 ==> 22 ==> 22
 9 / 3 ==> 몫 3, 나머지 0 ==> 3 / 3 ==> 몫 1, 나머지 0 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 100 ==> 24
10 / 3 ==> 몫 3, 나머지 1 ==> 3 / 3 ==> 몫 1, 나머지 0 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 101 ==> 41
11 / 3 ==> 몫 3, 나머지 2 ==> 3 / 3 ==> 몫 1, 나머지 0 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 102 ==> 42
12 / 3 ==> 몫 4, 나머지 0 ==> 4 / 3 ==> 몫 1, 나머지 1 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 110 ==> 44
13 / 3 ==> 몫 4, 나머지 1 ==> 4 / 3 ==> 몫 1, 나머지 1 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 111 ==> 111
14 / 3 ==> 몫 4, 나머지 2 ==> 4 / 3 ==> 몫 1, 나머지 1 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 112 ==> 112
15 / 3 ==> 몫 5, 나머지 0 ==> 5 / 3 ==> 몫 1, 나머지 2 ==> 1 / 3 ==> 몫 0, 나머지 1 ==> 120 ==> 112

나머지가 0일 때 4를 넣고, 다음 과정을 진행 시 몫에서 - 1을 하고 진행 함

const arr = ['4', '1', '2'];
let result = '';

(처음) n을 3으로 나눠 몫과 나머지로 분리한다

몫이 0이 아니고 나머지가 0인 경우 => result += arr[나머지], 몫에서 1을 빼고 이 값을 n으로 넣고 처음으로 돌아간다
몫이 0이 아니고 나머지가 0이 아닌 경우 => result += arr[나머지], 몫을 n으로 넣고 처음으로 돌아간다
몫이 0이고 나머지가 0이 아닌 경우(마지막 사이클) => result += arr[나머지], 반복문을 종료한다
몫이 0이고 나머지가 0인 경우 ==> 없음

result를 reverse하고 return;
*/
```

정말 많이 헤매다가 규칙성을 찾았다

처음에는 `3진법으로 그냥 고치고 0대신 4를 넣으면 되는거 아닐까?`라고 생각했는데 생각보다 많은 오류가 있었다

그래서 직접 일일이 3진법과의 비교를 통해 규칙성을 찾아내고 이를 의사코드로 구현한 후 코드로 옮겼다

근데 우수 풀이를 보니까 정말 간결한 코드를 보았다

```js
function change124(n) {
  return n === 0 ? '' : change124(parseInt((n - 1) / 3)) + [1, 2, 4][(n - 1) % 3];
}
```

재귀함수로 풀면 간혹 반복문보다 깔끔한 코드를 짤 수 있다는 것을 알 수 있게 되었다